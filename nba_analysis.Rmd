---
title: "NBA Analysis"
author: "Marco Lagos"
date: "2023-04-06"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(dplyr)
library(tidyr)
library(stringr)
```

Read in the data sets (advanced_stats.csv, nba_salaries.csv, nba_team_wins.csv, 
shooting_opponent.csv, shooting_team.csv, total_opponent.csv, total_team.csv)
```{r}
nba_salaries <- read.csv("./data/nba_salaries.csv")
nba_team_wins <- read.csv("./data/nba_team_wins.csv")

advanced_stats <- read.csv("./data/advanced_stats.csv")

shooting_stats <- read.csv("./data/shooting_stats.csv")
opponent_shooting_stats <- read.csv("./data/opponent_shooting_stats.csv")

total_stats <- read.csv("./data/total_stats.csv")
opponent_total_stats <- read.csv("./data/opponent_total_stats.csv")

gdp_deflator <- read.csv("./data/gdp_by_year.csv")

# View(nba_salaries)
# View(nba_team_wins)
# View(advanced_stats)
# View(shooting_stats)
# View(opponent_shooting_stats)
# View(total_stats)
# View(opponent_total_stats)
# View(gdp_deflator)

total_stats
```

Linear regression plot of team wins on total team salary. There needs to be 
inflation adjustment to the previous years so that salary is consistent. Then,
we will plot the the team wins to the total adjusted team salary by year.

We can use different index to make our USD adjustments over the course of the 20
years. Let us just choose our base year to be 2020.
1. Consumer Price Index (CPI)
	- Base Year CPI * (Current Year value / Current Year CPI)
	- This will give the adjusted amount of USD for that current year according
	  to the CPI index
2. Gross Domestic Product Deflator (GDP Deflator)
	- Base Year GDP * (Current Year value / Current Year GDP)
	- This will give the adjusted amount of USD for that current year according
	  to the CPI index
Why did we choose 2020 as the base year? Our intentions are to adjust the USD as
close as we can for the current year, so that viewers can better understand our 
analysis.

```{r}
adjust_salary_gdp_deflator <- function(base_year, nba_salaries, gdp_deflator) {
  base_year_gdp_value <- filter(gdp_deflator, year == base_year)$value

  adjusted_salary <- c()
  for (i in 1:nrow(nba_salaries)) {
  	current_year <- nba_salaries[i, 6]
	current_year_gdp_value <- filter(gdp_deflator, year == current_year)$value
	factor <- base_year_gdp_value / current_year_gdp_value
	adjusted_salary[i] <- nba_salaries[i, 5] * factor
  }
  nba_salaries <- cbind(nba_salaries, adjusted_salary)
  
  return(nba_salaries)
}

base_year <- 2020
adjusted_nba_salaries <- adjust_salary_gdp_deflator(base_year, nba_salaries, gdp_deflator)

total_salary <- adjusted_nba_salaries %>% group_by(year, team) %>% summarize(total_salary = sum(adjusted_salary))

# colnames(total_salary) is "year", "team", "total_salary"

create_total_salary_to_wins <- function(total_salary, wins) {
	wins_long <- nba_team_wins %>% pivot_longer(cols = names(nba_team_wins)[-1], names_to="team", values_to = "wins") %>% mutate(team = str_replace_all(team, "\\.", " "))
	
	total_salary$team <- str_to_lower(str_trim(total_salary$team))
	wins_long$team <- str_to_lower(str_trim(wins_long$team))
	
	merged_data <- left_join(total_salary, wins_long, by = c("year", "team"))
	names(merged_data) <- c("year", "team", "total_salary", "wins")
	return(merged_data)
}
total_salary_to_wins <- create_total_salary_to_wins(total_salary, nba_team_wins)
# colnames(total_salary_to_wins) is "year", "team", "total_salary", and "wins"
total_salary_to_wins <- na.omit(total_salary_to_wins)

# total_salary column for 2000, Atlanta Hawks was 23346098.
# Total wins for 2000, Atlanta Hawks was 25.

```
```{r}
library(glmnet)
set.seed(50)


# Get rid of the asterisks in every Team Name in advanced_stats.csv
advanced_stats <- read.csv("./data/advanced_stats.csv")
advanced_stats
advanced_stats$team <- stringr::str_replace(advanced_stats$team, '\\*', '')
advanced_stats

total_stats$team <- stringr::str_replace(total_stats$team, '\\*', '')
total_stats

opponent_total_stats$team <- stringr::str_replace(opponent_total_stats$team, '\\*', '')
opponent_total_stats

# names(advanced_stats)[] = "new_column_name"

# append = FALSE will destroy the existing file and then replace it with the variable
# advanced_stats which we are writing to that file.
# quote = FALSE will make sure that no elements are surrounded by quotation marks
# when we write these elements to the file.
# write.csv(advanced_stats, "./data/advanced_stats_without_asterisk.csv", append = FALSE, quote = FALSE)

# NOTE: The "Unnamed: 17", "Unnamed: 22", and "Unnamed: 27" columns of advanced_stats are
# not useful. They contain
# empty values or no values (idk). Just do not use these three columns.


# START OF ACTUALLY NEEDED CODE. THE CODE IN THIS BLOCK THAT IS ABOVE THIS LINE CAN BE DELETED.
create_wins_long <- function(wins) {
  # NOTE THAT THIS FUNCTION USES nba_team_wins, I THINK IT SHOULD TECHNICALLY USE "wins"
  # which is more specific to what was actually passed into this function create_wins_long.
	wins_long <- nba_team_wins %>% pivot_longer(cols = names(nba_team_wins)[-1], names_to="team", values_to = "wins") %>% mutate(team = str_replace_all(team, "\\.", " "))
	
	wins_long$team <- str_to_lower(str_trim(wins_long$team))
	
	return(wins_long)
}

# nba_team_wins
wins_long_res <- create_wins_long(nba_team_wins)
wins_long_res

# Assume that every string in the "team" column of wins_long_inside
# has already been trimmed and converted to lower case, BEFORE you pass it
# into this function.
create_df_stats_to_wins <- function(my_df_inside, wins_long_inside) {
	
  my_df_inside$team <- stringr::str_replace(my_df_inside$team, '\\*', '')
  
  # All the team names in wins_long$team is already trimmed and converted to lower case.
  # Therefore we should trim and convert to lower case all the team names inside
  # advanced_stats_inside.
	my_df_inside$team <- str_to_lower(str_trim(my_df_inside$team))
	
	# advanced_stats_bool_of_team_vec <- ifelse(wins_long_inside.contains(dvanced_stats_inside$team))
	# advanced_stats_bool_of_year_vec <- ifelse(wins_long_inside.contains(dvanced_stats_inside$team))
	
	
	
	# MAYBE USE THIS FOR LATER.
	# advanced_stats_bool_of_team_vec <- ifelse(wins_long_inside.contains(advanced_stats_inside$team)
	#                                          AND wins_long_inside.contains(advanced_stats_inside$year))
	
	# advanced_stats_inside <- advanced_stats_inside[advanced_stats_bool_of_team_vec]
	
	
	#	wins_long_bool_of_team_vec <- ifelse(advanced_stats_inside.contains(wins_long_inside$team)
	#                                          AND advanced_stats_inside.contains(wins_long_inside$year))
	
	# wins_long_inside <- wins_long_inside[wins_long_bool_of_team_vec]
	
	
	
	# We could do a simple ifelse or a filter that removes all the rows in advanced_stats_inside
	# and removed all the rows in wins_long_inside that correspond to a year-team combination
	# that does NOT exist in both advanced_stats_inside and wins_long_inside.
	
	# left_join has a argument called "fill = list(wins = 0)"
	merged_data <- left_join(my_df_inside, wins_long_inside, by = c("year", "team"))
	# names(merged_data) <- c("year", "team", "total_salary", "wins")
	return(merged_data)
}

my_df <- advanced_stats
# generate_plots_with_df <- function(my_df) {
  # my_df should have a "team" column, a "year" column,
  # and a bunch of columns which represent x variables.
  # my_df should NOT already have a "wins" column.
  
  my_df$team <- stringr::str_replace(my_df$team, '\\*', '')
  
  my_df_to_wins <- create_df_stats_to_wins(my_df, wins_long_res)
  
  rsquared_vec <- c()
  rsquared_adj_vec <- c()

  num_cols_in_df <- ncol(my_df_to_wins)  
  col_inds_vec <- seq(from = 1, to = num_cols_in_df, by = 1)
  
  # We want to avoid comparing a given column to wins
  # if that column contains String values (like the "team" column),
  # or if that column is the Rank of the team, or if that column
  # is the number of wins, or if that column is one of the x variables
  # whose meaning is so close to winning games (for example, the percentage
  # of 3-Point Goals or the number of goals), that we want to avoid it.
  
  # We can definitely include "ORtg"
  col_names_to_avoid <- c("Rk", "team", "W","L", "PW", "PL", "MOV", "Arena", "wins", "SRS", "ORtg", "DRtg", "NRtg")
  
  # for (col_i in col_inds_vec) {
  #   # Column Index 3 should be "Age"
  #   # Column Index 29 should be "year"
  #   cur_col_name <- colnames(total_with_opponent_total_stats_to_wins)[col_i]
  #   
  #   if (cur_col_name %in% col_names_to_avoid) {
  #     next
  #   }
  #   
  #   plot(my_df_to_wins[,col_i], my_df_to_wins$wins, xlab = cur_col_name, ylab = "wins")
  #   
  #   # Warning: NAs introduced by coercionWarning: no non-missing arguments to min; returning InfWarning: no non-missing arguments to max; returning -InfError in plot.window(...) : need finite 'xlim' values
  #   
  #   cur_mod <- lm(my_df_to_wins$wins ~ my_df_to_wins[,col_i])
  #   # names(lm$coefficients) <- c("(Intercept)", "x1")
  #   
  #   # print("HI current col name is")
  #   # print(colnames(my_df_to_wins)[col_i])
  #   # # print(summary(cur_mod))
  #   # print(summary(cur_mod)$r.squared)
  #   # print(summary(cur_mod)$adj.r.squared)
  #   
  #   rsquared_vec <- append(rsquared_vec, summary(cur_mod)$r.squared)
  #   rsquared_adj_vec <- append(rsquared_adj_vec, summary(cur_mod)$adj.r.squared)
  # }
  
  # find_forward_selected_model(my_df_to_wins)
  
  # find_LASSO_selected_model(my_df_to_wins)
  
  my_df_to_wins <- na.omit(my_df_to_wins)
  
  my_df_just_x <- my_df_to_wins[!names(my_df) %in% col_names_to_avoid]
  # message("MY_DF_JUST_X =========================")
  # message(dim(my_df_just_x))
  # message(typeof(my_df_just_x))
  # 
  # message(my_df_just_x[,1])
  
  print("MY_DF_JUST_X =========================")
  print(dim(my_df_just_x))
  print(typeof(my_df_just_x))
  
  print(my_df_just_x[,1])
  
  my_df_just_wins <- my_df_to_wins$wins
  # message("MY_DF_JUST_WINS =========================")
  # message(length(my_df_just_wins))
  # message("Right before printing out my_df_just_wins")
  # message(my_df_just_wins)
  
  print("MY_DF_JUST_WINS =========================")
  print(length(my_df_just_wins))
  print("Right before printing out my_df_just_wins")
  print(my_df_just_wins)
  
  print(any(is.na(my_df_just_x)))
  print(any(is.na(my_df_just_wins)))
  
  # my_df_just_x <- na.omit(my_df_just_x)
  # my_df_just_wins <- na.omit(my_df_just_wins)
  
  class(my_df_just_x)
  class(my_df_just_wins)
  lasso_model <- glmnet(x = data.matrix(my_df_just_x), y = data.matrix(my_df_just_wins), alpha = 1)
  # Call:  cv.glmnet(x = data.matrix(my_df_just_x), y = data.matrix(my_df_just_wins),      alpha = 1) 
  # Measure: Mean-Squared Error 
  # Lambda Index Measure      SE Nonzero
  # min 0.3593    39  0.1315 0.00677       1
  # 1se 0.3593    39  0.1315 0.00677       1
  
  
  # alpha = 1 specifies Lasso regularization
  # message("LASSO_MODEL =========================")
  # message(dim(lasso_model))
  # message(lasso_model)
  print("LASSO_MODEL =========================")
  print(dim(lasso_model))
  print(lasso_model)
  
  # print(lasso_model$beta)
  
  length(lasso_model$beta)
  print(dim(lasso_model$beta))
  num_cols <- dim(lasso_model$beta)[2]
  num_cols
  # printSpMatrix(lasso_model$beta[, 1:num_cols], col.names=TRUE)
  print(lasso_model$beta[,num_cols])
  
  
#  return (3)
#}

col_names_to_avoid <- c("Rk", "team", "wins", "Arena")

adv_col_bool_vec <- names(advanced_stats) %in% col_names_to_avoid
adv_col_bool_vec
adv_col_bool_vec <- !names(advanced_stats) %in% col_names_to_avoid
adv_col_bool_vec

# hi <- generate_plots_with_df(advanced_stats)
print("after generate_plots_with_df")






# advanced_stats_to_wins <- create_advanced_stats_to_wins(advanced_stats, wins_long_res)
# advanced_stats_to_wins
# 
# advanced_stats_to_wins <- na.omit(advanced_stats_to_wins)
# advanced_stats_to_wins
# 
# # 616 by 27
# total_stats_to_wins <- create_advanced_stats_to_wins(total_stats, wins_long_res)
# total_stats_to_wins
# 
# # 554 by 27
# total_stats_to_wins <- na.omit(total_stats_to_wins)
# total_stats_to_wins

```
```{r}

# wins_long_res
mod_just_intercept <- lm(wins_long_res$wins ~ 1)
mod_just_intercept
summary(mod_just_intercept)

```


```{r}

opponent_total_stats$team <- stringr::str_replace(opponent_total_stats$team, '\\*', '')
opponent_total_stats


total_with_opponent_total_stats <- left_join(total_stats, opponent_total_stats, by = c("year", "team"))
total_with_opponent_total_stats


# 616 by 27
total_with_opponent_total_stats_to_wins <- create_advanced_stats_to_wins(total_with_opponent_total_stats, wins_long_res)
total_with_opponent_total_stats_to_wins


# 553 by 27
total_with_opponent_total_stats_to_wins <- na.omit(total_with_opponent_total_stats_to_wins)
total_with_opponent_total_stats_to_wins

# 616 x 26, 616 x 50, 616 x 27, 553 x 27
```
```{r}


# Are we using ggplot2 ?

rsquared_vec <- c()
rsquared_adj_vec <- c()

col_inds_vec <- seq(from = 3, to = 50, by = 1)
for (col_i in col_inds_vec) {
  # Column Index 3 should be "Age"
  # Column Index 29 should be "year"
  
  
  plot(total_with_opponent_total_stats_to_wins[,col_i], total_with_opponent_total_stats_to_wins$wins, xlab = colnames(total_with_opponent_total_stats_to_wins)[col_i], ylab = "wins")
  
  # Warning: NAs introduced by coercionWarning: no non-missing arguments to min; returning InfWarning: no non-missing arguments to max; returning -InfError in plot.window(...) : need finite 'xlim' values
  
    cur_mod <- lm(total_with_opponent_total_stats_to_wins$wins ~ total_with_opponent_total_stats_to_wins[,col_i])
  # names(lm$coefficients) <- c("(Intercept)", "x1")
  
  print("HI current col name is")
  print(colnames(total_with_opponent_total_stats_to_wins)[col_i])
  # print(summary(cur_mod))
  print(summary(cur_mod)$r.squared)
  print(summary(cur_mod)$adj.r.squared)
  
  rsquared_vec <- append(rsquared_vec, summary(cur_mod)$r.squared)
  rsquared_adj_vec <- append(rsquared_adj_vec, summary(cur_mod)$adj.r.squared)
}

plot(x = col_inds_vec, y = rsquared_vec)

plot(x = col_inds_vec, y = rsquared_adj_vec)

rsquared_vec_sorted <- sort(rsquared_vec, decreasing=TRUE, index.return=TRUE)
rsquared_vec_sorted
# rsquared_vec_sorted$x

# total_stats_to_wins[, 2 + element in rsquared_vec_sorted$ix]
rsquared_vec_sorted$ix
# 7, 10, 13, 20, 25, 18

for (cur_x_ind in 1:7) {
  print(colnames(total_with_opponent_total_stats_to_wins)[rsquared_vec_sorted$ix[cur_x_ind] + 2 ])
}

mult_mod <- lm(total_with_opponent_total_stats_to_wins$wins ~ total_with_opponent_total_stats_to_wins[,35]
               + total_with_opponent_total_stats_to_wins[,10]
               + total_with_opponent_total_stats_to_wins[,38]
               + total_with_opponent_total_stats_to_wins[,13])

summary(mult_mod)
print(summary(mult_mod)$r.squared)
print(summary(mult_mod)$adj.r.squared)


```
Making the plot of team wins over advanced stats for the team for that year. Any NULL wins have been removed.
```{r}

plot(advanced_stats_to_wins$SOS, advanced_stats_to_wins$wins)
plot(advanced_stats_to_wins$X3PAr, advanced_stats_to_wins$wins)

advanced_stats_to_wins[3]
colnames(advanced_stats_to_wins)[3]
colnames(advanced_stats_to_wins)[29]
dim(advanced_stats_to_wins)

# Are we using ggplot2 ?
for (col_i in seq(from = 3, to = 29, by = 1)) {
  # Column Index 3 should be "Age"
  # Column Index 29 should be "year"
  
  
  plot(advanced_stats_to_wins[,col_i], advanced_stats_to_wins$wins, xlab = colnames(advanced_stats_to_wins)[col_i], ylab = "wins")
  
  # Warning: NAs introduced by coercionWarning: no non-missing arguments to min; returning InfWarning: no non-missing arguments to max; returning -InfError in plot.window(...) : need finite 'xlim' values
  
}



```
```{r}

col_inds_vec <- seq(from = 3, to = 26, by = 1)

rsquared_vec <- c()
rsquared_adj_vec <- c()
for (col_i in col_inds_vec) {
  # Column Index 3 should be "Age"
  # Column Index 29 should be "year"
  
  
  plot(total_stats_to_wins[,col_i], total_stats_to_wins$wins, xlab = colnames(total_stats_to_wins)[col_i], ylab = "wins")
  
  # Warning: NAs introduced by coercionWarning: no non-missing arguments to min; returning InfWarning: no non-missing arguments to max; returning -InfError in plot.window(...) : need finite 'xlim' values
  
  cur_mod <- lm(total_stats_to_wins$wins ~ total_stats_to_wins[,col_i])
  # names(lm$coefficients) <- c("(Intercept)", "x1")
  
  print("HI current col name is")
  print(colnames(total_stats_to_wins)[col_i])
  # print(summary(cur_mod))
  print(summary(cur_mod)$r.squared)
  print(summary(cur_mod)$adj.r.squared)
  
  rsquared_vec <- append(rsquared_vec, summary(cur_mod)$r.squared)
  rsquared_adj_vec <- append(rsquared_adj_vec, summary(cur_mod)$adj.r.squared)
}

plot(x = col_inds_vec, y = rsquared_vec)

plot(x = col_inds_vec, y = rsquared_adj_vec)

rsquared_vec_sorted <- sort(rsquared_vec, decreasing=TRUE, index.return=TRUE)
# rsquared_vec_sorted$x

rsquared_vec_sorted$ix
# 7, 10, 13, 20, 25, 18

for (cur_x_ind in 1:7) {
  print(colnames(total_stats)[rsquared_vec_sorted$ix[cur_x_ind] + 2 ])
}


# FG%, 3P%, 2P%, AST, PTS, DRB, BLK

# mult_mod <- lm(total_stats_to_wins$wins ~ total_stats_to_wins[,7]
#                + total_stats_to_wins[,10]
#                + total_stats_to_wins[,13]
#                + total_stats_to_wins[,20]
#                + total_stats_to_wins[,25]
#                + total_stats_to_wins[,18]
#                + total_stats_to_wins[,22])

mult_mod <- lm(total_stats_to_wins$wins ~ total_stats_to_wins[,10]
               + total_stats_to_wins[,13]
               + total_stats_to_wins[,20]
               + total_stats_to_wins[,18]
               + total_stats_to_wins[,22])
# names(lm$coefficients) <- c("(Intercept)", "x1")

for (num_x_to_include in 1:24) {
  #lm()
}
summary(mult_mod)
print(summary(mult_mod)$r.squared)
print(summary(mult_mod)$adj.r.squared)

# For the old mult_mod which considered the 10, 13, 20, 25, 18, 22
# x variables in total_stats.csv, the r.squared was 0.4611394
# and the 0.4542309

# For the new mult_mod which considered the 10, 13, 20, 18, and 22
# x variables in total_stats.csv, the r.squared was 0.4006081
# and the 0.3951392



```
Making the plot of team wins over total salary paid to players for that year. The
salaries have been adjusted and any NULL wins have been removed.
```{r}
x <- total_salary_to_wins$total_salary
y <- total_salary_to_wins$wins

model <- lm(y ~ x)
summary(model)
plot(x, y)




```

