---
title: "Report"
author: "Zachary Katz"
date: "2023-04-08"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(psych)
library(ggplot2)
library(reshape2)
library(GGally)
library(dplyr)
library(tidyr)
library(stringr)
library(scales)
library(glmnet)
```
Read in csv files:
```{r}
# Player, Year, Salary, Team
adjusted_nba_salaries <- read.csv("./data/adjusted_nba_salaries.csv")
# Team, Year, Total Salary
total_salary_by_team <- read.csv("./data/total_salary_by_team.csv")
# Team, Year, Wins
nba_team_wins <- read.csv("./data/nba_team_wins.csv")
# See Report advanced stats description
advanced_stats <- read.csv("./data/advanced_stats.csv")
# See Report advanced stats description
advanced_stats_2021 <- read.csv("./data/2021_advanced.csv")
# See Report shooting stats description
shooting_stats <- read.csv("./data/shooting_stats.csv")
# See Report shooting stats description
opponent_shooting_stats <- read.csv("./data/opponent_shooting_stats.csv")
# See Report total stats description
total_stats <- read.csv("./data/total_stats.csv")
# See Report total stats description
opponent_total_stats <- read.csv("./data/opponent_total_stats.csv")

# advanced_stats.csv no longer has asterisks in some of its Team names,
# so I do not need to run these two lines below:
# advanced_stats$team <- stringr::str_replace(advanced_stats$team, '\\*', '')
# advanced_stats

# View(nba_salaries)
# View(nba_team_wins)
# View(advanced_stats)
# View(shooting_stats)
# View(opponent_shooting_stats)
# View(total_stats)
# View(opponent_total_stats)
```
Basic Summary
```{r}
print("==================================================")
print("NBA Salaries CSV")
# sapply(nba_salaries, summary)
describe(adjusted_nba_salaries)
print("==================================================")
print("NBA Total Salaries CSV")
# sapply(nba_salaries, summary)
describe(total_salary_by_team)
print("==================================================")
print("NBA Team Wins CSV")
# sapply(nba_team_wins, summary)
describe(nba_team_wins)
print("==================================================")
print("NBA Advanced Stats CSV")
# sapply(advanced_stats, summary)
describe(advanced_stats)
print("==================================================")
print("NBA Shooting Stats CSV")
# sapply(shooting_stats, summary)
describe(shooting_stats)
print("==================================================")
print("NBA Opponent Shooting Stats CSV")
# sapply(opponent_shooting_stats, summary)
describe(opponent_shooting_stats)
print("==================================================")
print("NBA Total Stats CSV")
# sapply(total_stats, summary)
describe(total_stats)
print("==================================================")
print("NBA Opponent Total Stats CSV")
# sapply(opponent_total_stats, summary)
describe(opponent_total_stats)
print("==================================================")
```
Basic Visualization of the Means and Variances of the X Variables
```{r}
# NOTE THAT THIS BLOCK OF CODE DOES CHANGE advanced_stats BY GETTING RID OF NA
# VALUES IN advanced_stats.


#advanced_stats
#class(advanced_stats[,2])
#advanced_stats[,2][1]
#advanced_stats[,2][2]
#advanced_stats[,2][3]

#dim(advanced_stats)

advanced_stats <- na.omit(advanced_stats)
dim(advanced_stats)

# ifelse(advanced_stats$year == cur_year, 1, 0)

years_vec <- seq(from = 2000, to = 2019, by = 1)
# for (cur_year in years_vec) {
# advanced_stats_only_cur_year <- advanced_stats[advanced_stats$year == cur_year,]
# print(dim(advanced_stats_only_cur_year))
# 
# col_inds_vec <- seq(from = 3, to = 20, by = 1)
# for (cur_x_ind in col_inds_vec) {
#   mu_of_cur_x_cur_year <- mean(advanced_stats_only_cur_year[,cur_x_ind])
#   
# }
# }

any(advanced_stats["Age"] == "26.9")

any(is.na(advanced_stats["Age"]))
any(is.na(advanced_stats["W"]))

colnames(advanced_stats)[28]

alpha_level <- 0.05

# If alpha is 0.05, then area_to_the_left should be 0.975
area_to_the_left <- (1.0 - (alpha_level/2.0))
area_to_the_left
norm_crit_value <- qnorm(area_to_the_left, mean = 0, sd = 1, lower.tail = TRUE)
norm_crit_value

generate_general_plots <- function(my_df) {
col_inds_vec <- seq(from = 3, to = dim(my_df)[2], by = 1)
for (cur_x_ind in col_inds_vec) {
  # if cur_x_ind corresponds to the "Arena" column,
  # then skip this current iteration
  # because the "Arena" column contains string values
  # which obviously can not be averaged.
  if (cur_x_ind == 26) {
    next
  }
  
  cur_x_means <- c()
  cur_x_sds <- c()
  cur_x_lower_bounds <- c()
  cur_x_upper_bounds <- c()
  
  print("HI")
  print(colnames(my_df)[cur_x_ind])
  for (cur_year in years_vec) {
    advanced_stats_only_cur_year <- my_df[my_df$year == cur_year,]
    # advanced_stats_only_cur_year <- advanced_stats[,cur_x_ind]
    
    mu_of_cur_x_cur_year <- mean(advanced_stats_only_cur_year[,cur_x_ind])
    sd_of_cur_x_cur_year <- sd(advanced_stats_only_cur_year[,cur_x_ind])
    
    if (cur_x_ind == 3) {
      print(sd_of_cur_x_cur_year)
    }
    
    cur_x_means <- append(cur_x_means, mu_of_cur_x_cur_year)
    cur_x_sds <- append(cur_x_sds, sd_of_cur_x_cur_year)
    cur_x_lower_bounds <- append(cur_x_lower_bounds, mu_of_cur_x_cur_year - norm_crit_value*sd_of_cur_x_cur_year)
    cur_x_upper_bounds <- append(cur_x_upper_bounds, mu_of_cur_x_cur_year + norm_crit_value*sd_of_cur_x_cur_year)
  }
  
  # Make a plot of the mean of the current x-variable over the 20 years.
  

  print(cur_x_means)
  if (cur_x_ind == 3) {
    print("cur_x_means is")
    print(cur_x_means)
    print("cur_x_lower_bounds is")
    print(cur_x_lower_bounds)
  }
  
  min_y_lower_bound <- min(cur_x_lower_bounds)
  max_y_upper_bound <- max(cur_x_upper_bounds)
  midpoint_y <- ((max_y_upper_bound + min_y_lower_bound)/2.0)
  half_range_y <- ((max_y_upper_bound - min_y_lower_bound)/2.0)
  
  ylim_lower_bound <- (midpoint_y - half_range_y*1.5)
  ylim_upper_bound <- (midpoint_y + half_range_y*1.5)
  
  #plot(years_vec, cur_x_means, xlab = "Year", ylab = colnames(advanced_stats)[cur_x_ind],
  #     ylim = c(min_y_lower_bound-2, max_y_upper_bound+2))
  plot(years_vec, cur_x_means, xlab = "Year", ylab = colnames(my_df)[cur_x_ind],
       ylim = c(ylim_lower_bound, ylim_upper_bound))
  for (cur_year_ind in 1:length(years_vec)) {
    lines(c(years_vec[cur_year_ind], years_vec[cur_year_ind]), c(cur_x_lower_bounds[cur_year_ind], cur_x_upper_bounds[cur_year_ind]))
  }
}

}



generate_general_plots(advanced_stats)

generate_general_plots(total_stats)


```

Basic Visualization (Correlation Matrices)
```{r}
# =========================================================
#				Correlation Matrices
# =========================================================
create_correlation_matrix <- function(data, name) {
	# Create correlation matrix
	numeric_data <- data[, sapply(data, is.numeric)]
	
	# Remove rows with missing values
	numeric_data <- numeric_data[complete.cases(numeric_data),]

	cor_mat <- cor(numeric_data)
	
	# Melt correlation matrix into long format for ggplot2
	cor_melt <- melt(cor_mat)
	
	# Create ggplot2 plot of correlation matrix
	ggplot(cor_melt, aes(x = Var1, y = Var2, fill = value)) +
	  geom_tile() +
	  scale_fill_gradient2(low = "blue", high = "red", mid = "white", midpoint = 0) +
	  theme_minimal() +
	  theme(axis.text.x = element_text(angle = 45, hjust = 1),
	        legend.title = element_blank()) +
	  labs(title = name)
}

create_correlation_matrix(total_stats, "Correlation Matrix of Total Statistics Variables")
create_correlation_matrix(opponent_total_stats, "Correlation Matrix of Opponent Total Statistics Variables")
create_correlation_matrix(advanced_stats, "Correlation Matrix of Advanced Statistics Variables")
create_correlation_matrix(shooting_stats, "Correlation Matrix of Shooting Statistics Variables")
create_correlation_matrix(opponent_shooting_stats, "Correlation Matrix of Opponent Shooting Statistics Variables")
```
Basic Visualization (Scatterplot Matrices)
```{r}
# =========================================================
#				ScatterPlot Matrices
# =========================================================
create_stat_to_wins <- function(stat) {
	stat$year <- as.integer(stat$year)
	merged_data <- left_join(stat, nba_team_wins, by = c("year", "team"))
	merged_data <- na.omit(merged_data)
	return(merged_data)
}

total_stats_wins <- create_stat_to_wins(total_stats)

# Relationship between wins and field goal attempts
ggpairs(total_stats_wins[,c("wins", "PTS", "FGA", "X3PA", "X2PA", "FTA")], title = "Scatterplot Matrix for Team Wins, Points Scored, and Shooting Percentages")
# Relationship between wins and field goal percentage
ggpairs(total_stats_wins[,c("wins", "PTS", "FGA", "X3P.", "X2P.", "FT.")], title = "Scatterplot Matrix for Team Wins, Points Scored, and Shooting Percentages")
# Relationship between wins and rebounds (*total rebounds*)
ggpairs(total_stats_wins[,c("wins", "PTS", "ORB", "DRB", "TRB")], title = "Scatterplot Matrix for Team Wins, Points Scored, and Shooting Percentages")
# Relationship between wins and assists, blocks, turnovers, personal fouls
ggpairs(total_stats_wins[,c("wins", "PTS", "AST", "BLK", "TOV", "PF")], title = "Scatterplot Matrix for Team Wins, Points Scored, and Shooting Percentages")
```
Basic Visualization (Boxplots)
```{r}
# =========================================================
#				Bubble Charts
# =========================================================
nba_total_salary_to_wins <- create_stat_to_wins(total_salary_by_team)

salary_wins_advanced <- left_join(advanced_stats, nba_total_salary_to_wins, by = c("year", "team"))
salary_wins_advanced <- na.omit(salary_wins_advanced)

salary_wins_advanced_total <- left_join(total_stats, nba_total_salary_to_wins, by = c("year", "team"))
salary_wins_advanced_total <- na.omit(salary_wins_advanced_total)

bubble_data <- data.frame(
  team_wins = salary_wins_advanced_total$wins,
  salary = salary_wins_advanced_total$total_salary,
  total_rebounds = salary_wins_advanced_total$TRB
)
ggplot(bubble_data, aes(x = salary, y = total_rebounds, size = team_wins, color = total_rebounds)) +
  geom_point() +
  scale_size_continuous(range = c(2, 10)) +
  labs(x = "Salary", y = "Total Rebounds", size = "Team Wins") + scale_color_gradient(low = "blue", high = "red")
```
Basic Visualization (Stacked Bar Plot)
```{r}
# =========================================================
#				Stacked Bar Plot
# =========================================================
# Creating a subset of total_stats dataframe for selected variables
team_stats <- total_stats[, c("team", "PTS", "AST", "TRB", "TOV")]

# Calculating the total of each variable by team
team_stats_summary <- aggregate(. ~ team, data = team_stats, FUN = sum)

# Converting data from wide to long format
team_stats_long <- gather(team_stats_summary, key = "stat", value = "total", -team)

# Creating the stacked bar chart
ggplot(team_stats_long, aes(x = team, y = total, fill = stat)) +
  geom_bar(stat = "identity") +
  ggtitle("Composition of Total Team Statistics") +
  xlab("Team") +
  ylab("Total") +
  theme_minimal() +
  theme(legend.position = "bottom")
```
Basic Analysis (Principal Component Analysis)
```{r}
nba_total_to_wins <- create_stat_to_wins(total_stats)

# Removing non-numeric columns
numeric_data <- nba_total_to_wins[, sapply(nba_total_to_wins, is.numeric)]

# Removing rows with missing values
numeric_data <- na.omit(numeric_data)

scaled_data <- scale(numeric_data)
pca <- prcomp(scaled_data, center = TRUE, scale. = TRUE)

# Extracting the first two principal components
pca_data <- data.frame(pca$x[,1:2])

# Extracting the loadings
loadings <- data.frame(pca$rotation[,1:2])

# Performing PCA on numeric data
pca <- prcomp(numeric_data, center = TRUE, scale. = TRUE)

# Extract the first two principal components and create a data frame
pca_data <- data.frame(pca$x[, 1:2], team = nba_total_to_wins$team)

# Extracting loadings and creating a data frame
loadings <- data.frame(variable = colnames(numeric_data), 
                       PC1 = pca$rotation[, 1], 
                       PC2 = pca$rotation[, 2])

# Plotting the loadings on the first two principal components
ggplot(pca_data, aes(x = PC1, y = PC2)) + 
  geom_point(aes(color = team)) + 
  geom_hline(yintercept = 0, linetype = "dashed") + 
  geom_vline(xintercept = 0, linetype = "dashed") + 
  geom_text(data = loadings, aes(x = PC1, y = PC2, label = variable), size = 3) +
  ggtitle("PCA: Loadings Plot")

```
Generating Model using LASSO selection on Advanced NBA Statistics
```{r}
add_wins_vector <- function(data) {
	data_to_wins <- left_join(data, nba_team_wins, by = c("year", "team"))
	data_to_wins <- na.omit(data_to_wins)
	return(data_to_wins)
}

generate_advanced_stats_model <- function(data, exclude, selection_type, title) {

	data_to_wins <- add_wins_vector(data)
  
	rsquared_vec <- c()
	rsquared_adj_vec <- c()

	cols <- ncol(data_to_wins)  
	column_iterator <- seq(from = 1, to = cols, by = 1)
  
	col_names_to_avoid <- exclude
	predictor_variables_df <- data_to_wins[!names(data_to_wins) %in% col_names_to_avoid]
	
	print("Number of Regressors:")	
	print(dim(predictor_variables_df)[2])

	print("LASSO Model for prediction of NBA team success based on NBA Advanced Stats")
	print("==================================================")
	print("Predictor Variables for LASSO model:")
	print(dim(predictor_variables_df))
	print(colnames(predictor_variables_df))
  
	wins_col_vector <- data_to_wins$wins

	print("==================================================")
	print("Response Variable for LASSO Model:")
	print(length(wins_col_vector))
	
	stopifnot(!any(is.na(predictor_variables_df)), !any(is.na(wins_col_vector)))
	model <- glmnet(x = data.matrix(predictor_variables_df), y = data.matrix(wins_col_vector), alpha = selection_type)
	num_cols <- dim(model$beta)[2]

	print("==================================================")
	print("Lambda Values tested by LASSO model:")
	print("---------------------------------------------------")
	print(model$lambda[num_cols])
	print("")
	print("Beta Values generated by LASSO model (best lambda):")
	print("---------------------------------------------------")
	print(model$beta[,num_cols])
	print("")
	print("LASSO model R-squared:")
	print("---------------------------------------------------")
	print(model$dev.ratio[num_cols])
	print("==================================================")
	print("")
	print("LASSO model ADJUSTED R-squared:")
	print("---------------------------------------------------")
	print(model$dev.ratio[num_cols])
	print("==================================================")
	
	# Creating a plot of the lambda values tested by the Lasso model
	plot(model$lambda, model$dev.ratio, type = "b", xlab = "Lambda", ylab = "Deviance Ratio", main = title)
	
	# Create a sample matrix
	beta_vals <- model$beta[,num_cols]
	barplot(beta_vals, col="blue", main="Lasso Model Beta Values", las=2)
	par(cex.axis=0.8, cex.main=1.0)
	
	return (model)
}

aparam <- c("Rk", "team", "W","L", "PW", "PL", "MOV", "Arena", "wins", "SRS", "ORtg", "DRtg", "NRtg", "TS.", "eFG..1", "eFG.", "FT.FGA")
aparam_min <- c("Rk", "team", "W","L", "PW", "PL", "MOV", "Arena", "wins", "ORtg", "NRtg", "TS.", "eFG..1", "eFG.")

#advanced_stats_lasso_model <- generate_advanced_stats_model(advanced_stats, aparam, 1, "Lasso Model: Lambda vs. Deviance Ratio (AParam)")
#advanced_stats_ridge_model <- generate_advanced_stats_model(advanced_stats, aparam, 0, "Ridge Model: Lambda vs. Deviance Ratio (AParam)")

advanced_stats_lasso_model_min <- generate_advanced_stats_model(advanced_stats, aparam_min, 1, "Lasso Model: Lambda vs. Deviance Ratio (Min AParams)")
advanced_stats_ridge_model_min <- generate_advanced_stats_model(advanced_stats, aparam_min, 0, "Ridge Model: Lambda vs. Deviance Ratio (Min AParams)")
```

```{r}
predict_team_success <- function(team, model, exclude, title) {
	advanced_stats_team <- advanced_stats[advanced_stats$team == team,]
	
	advanced_stats_team_wins <- add_wins_vector(advanced_stats_team)
	advanced_stats_team_wins_predictors <- advanced_stats_team_wins[!names(advanced_stats_team_wins) %in% exclude]

	num_cols <- dim(model$beta)[2]
	best_lambda_value <- model$lambda[num_cols]
	
	print("Number of Regressors:")
	print(dim(advanced_stats_team_wins_predictors)[2])
	print(names(advanced_stats_team_wins_predictors))
	
	results <- predict(model, newx=data.matrix(advanced_stats_team_wins_predictors), s=best_lambda_value, type="response")
	
	plot(advanced_stats_team_wins$year, results, col = "red", xlab = "Year", ylab = paste("Wins for ", team, ""), main=title)
	points(advanced_stats_team_wins$year, advanced_stats_team_wins$wins, col = "grey")
	legend("topright", legend = c("Predicted wins", "Actual Wins"), col = c("grey", "green"), pch=1)
	
	return(results)
}


results_lasso <- predict_team_success("houston rockets", advanced_stats_lasso_model, aparam, "Lasso AParams")
results_ridge <- predict_team_success("houston rockets", advanced_stats_ridge_model, aparam, "Ridge AParams")

results_lasso_min <- predict_team_success("houston rockets", advanced_stats_lasso_model_min, aparam_min, "Lasso Min AParams")
results_ridge_min <- predict_team_success("houston rockets", advanced_stats_ridge_model_min, aparam_min, "Ridge Min AParams")

```
Applying our model to future data and conducting a residual analysis
```{r}
predict_on_future_data <- function(future_data, model, exclude, title) {
	  future_data_predictors <- future_data[!names(future_data) %in% exclude]
	  
	  year_str <- future_data$year[1]
	  
	  
	  num_cols <- dim(model$beta)[2]
	  best_lambda_value <- model$lambda[num_cols]
	  
	  print("Number of Regressors:")
	  print(dim(future_data_predictors)[2])
	  print(names(future_data_predictors))
	  
	  new_year_string <- paste("Wins for Teams in", year_str)
	  
	  results <- predict(model, newx=data.matrix(future_data_predictors), s=best_lambda_value, type="response")
	  
	  team_inds <- seq(from=1, to=length(future_data$team), by=1)
	  plot(team_inds, results, col = "red", xlab = "Team", ylab = new_year_string, ylim=c(10, 90), main=title)
	  
	  points(team_inds, future_data$W, col = "grey")
	  legend("topright", legend = c("Predicted wins", "Actual Wins"), col = c("red", "grey"), pch=1)
	  

	
	  
	  
	  # Compute the residuals
	  residuals <- results - future_data$W
	  
	  print(dim(results))
	  print(length(results[,1]))
	  print(length(residuals))
	   
	  print(results)
	  plot(results, residuals, col = "red", xlab = "Predicted values", ylab = "Residuals", main="Residuals versus predicted values")
	  
	  # Return both the predicted values and residuals
	  return(list(predictions = results, residuals = residuals))
}

# NOTE: You can only really pass a Ridge Model to this function "compute_studentized_residuals",
# Because this function uses the special formula for calculating
# the Hat matrix that is only true for a Ridge model.
compute_studentized_residuals <- function(future_data, model, res_vec, exclude, k, pred_vals) {
  # Need the MS_Res of our model on the n data points
  # For every integer i (1 <= i <= n), we need the h_ii, which depends on n, the
  # value of x_i, the value of the sample mean of x (so x_bar or mu_x_hat), and
  # finally the value of S_xx.
  
  n_points <- length(res_vec)
  
  names_of_vars_that_model_uses <- names(advanced_stats_ridge_model$beta[,100])
  # future_data_predictors <- future_data[!names(future_data) %in% exclude]
  future_data_predictors <- future_data[names(future_data) %in% names_of_vars_that_model_uses]
  
  # k <- dim(future_data_predictors)
  
  
  # future_data$W is true value of y
  SS_Res <- sum((future_data$W - res_vec)^2)
  MS_Res <- SS_Res / (n_points - k - 1)
  
  # S_xx <- sum((future))
  
  
  # H = X (X^T *X)^-1 X^T
  X_mat <- as.matrix(future_data_predictors)
  print(dim(X_mat))
  print(n_points)
  
  I_mat <- diag(k)
  X_t_times_X <- t(X_mat) %*% X_mat
  dim(X_t_times_X)
  scaled_I_mat <- model$lambda[dim(model$beta)[2]] * I_mat
  X_prod_before_inv <- (X_t_times_X) + scaled_I_mat
  hat_matrix <- (X_mat %*% solve(X_prod_before_inv) %*% t(X_mat))
  
  hat_matrix_diag <- diag(hat_matrix)
  hat_diag_len <- length(hat_matrix_diag)
  print(hat_diag_len)
  
  # studres(model) will probably calculate Studentized Residuals
  # but on the data that the model was trained on, which is not what
  # we want to do.
  # studres(model)
  
  stud_res_vec <- (res_vec)/(sqrt(MS_Res * (1-hat_matrix_diag)))
  
  #team_inds <- seq(from=1, to=length(future_data$team), by=1)
	plot(pred_vals, stud_res_vec, col = "red", xlab = "Predicted values", ylab = "Studentized residuals", main="Studentized residuals versus Predicted Y")
	
	#leverage_vals <- hat_matrix_diag
	hat_matrix_diag_bar <- sum(hat_matrix_diag)/hat_diag_len
	
	min_x_to_show <- 0.9*min(hat_matrix_diag)
	max_x_to_show <- max(max(hat_matrix_diag), 1.1*2*hat_matrix_diag_bar)
	plot(hat_matrix_diag, stud_res_vec, col = "red", xlab = "Leverage values", ylab = "Studentized residuals", xlim = c(min_x_to_show, max_x_to_show), main="Studentized residuals versus Leverage values")

	
	abline(v = 2*hat_matrix_diag_bar, col="blue")
	legend("bottomleft", legend = c("x=2h_bar"), pch="|", col="blue")
	  
	#points(team_inds, pred_vals, col = "grey")
	#legend("topright", legend = c("Predicted wins", "Actual Wins"), col = c("red", "grey"), pch=1)
	  
  return (stud_res_vec)
}



#residuals_future_lasso <- predict_on_future_data(advanced_stats_2021, advanced_stats_lasso_model, aparam, "Lasso AParam Prediction on Future Data")
#residuals_future_ridge <- predict_on_future_data(advanced_stats_2021, advanced_stats_ridge_model, aparam, "Ridge AParam Prediction on Future Data")
#residuals_future_lasso_min <- predict_on_future_data(advanced_stats_2021, advanced_stats_lasso_model_min, aparam_min, "Lasso Min AParam Prediction on Future Data")
residuals_future_ridge_min <- predict_on_future_data(advanced_stats_2021, advanced_stats_ridge_model_min, aparam_min, "Ridge Min AParam Prediction on Future Data")

# Lambda that the model ended up using:
# model$lambda[dim(model$beta)[2]]



k <- dim(advanced_stats_ridge_model$beta)[1]
stud_residuals_future_lasso_min <- compute_studentized_residuals(advanced_stats_2021, advanced_stats_ridge_model_min, residuals_future_ridge_min$residuals, aparam_min, k, residuals_future_ridge_min$predictions)


# aparm has "SRS", "DRtg", "FT.FGA"
```
```{r}
training_data <- advanced_stats
training_data
model <- advanced_stats_lasso_model
exclude <- aparam
title <- "Lasso AParam Prediction on Training Data"
# predict_on_training_data <- function(training_data, model, exclude, title) {
  # training_data is 616 rows by 17 columns
  # future_data would be 31 rows by 17 columns
  
  # Get rid of some columns so that the number of columns becomes 17 columns
	  training_data_predictors <- training_data[!names(training_data) %in% exclude]
	  # for (year_val in 2000:2019) {
	  #   ifelse(training_data_predictors$year == year_val)
	  # }
	  
	  print(training_data_predictors)
	  
	  num_cols <- dim(model$beta)[2]
	  best_lambda_value <- model$lambda[num_cols]
	  
	  # 31 rows by 17 columns
	  unique_team_names <- unique(training_data$team)
	  
	  results_for_teams <- c()
	  true_wins_for_teams <- c()
	  for (cur_team_name in unique_team_names) {
	    print("BEFORE SELECTING JUST CUR_TEAM_NAME")
	    print(cur_team_name)
	    training_data_only_cur_team <- training_data[training_data$team == cur_team_name,]
	    print("BEFORE EXCLUDING THE VARIABLES IN EXCLUDE")
	    training_data_predictors_only_cur_team <-  training_data_only_cur_team[!names(training_data_only_cur_team) %in% exclude]
	    
	    # results_for_team should be 20 rows by 1 column
	    print("BEFORE PREDICTING THE WINS FOR CURRENT TEAM")
	    results_for_team <- predict(model, newx=as.matrix(training_data_predictors_only_cur_team), s=best_lambda_value, type="response")
	    
	    print("BEFORE CALCULATING THE MEAN OF PREDICTED WINS FOR CURRENT TEAM")
	    results_for_team_mean <- mean(results_for_team)
	    print("BEFORE ADDING THE MEAN OF PREDICTED WINS FOR CURRENT TEAM TO THE RESULTS_FOR_TEAMS")
	    results_for_teams <- append(results_for_teams, results_for_team_mean)
	    
	    print("BEFORE CALCULATING THE MEAN OF ACTUAL WINS FOR CURRENT TEAM")
	    true_win_for_team_mean <- mean(training_data_only_cur_team$W)
	    print(true_win_for_team_mean)
	    print("BEFORE ADDING THE MEAN OF PREDICTED WINS FOR CURRENT TEAM TO THE RESULTS_FOR_TEAMS")
	    true_wins_for_teams <- append(true_wins_for_teams, true_win_for_team_mean)
	  }
	  
	  
	  year_str <- training_data$year[1]
	  
	  print("Number of Regressors:")
	  print(dim(training_data_predictors)[2])
	  print(names(training_data_predictors))
	  
	  new_year_string <- "Wins for Teams (Averaged across 20 seasons)"
	  
	  print(unique_team_names)
	  print(length(unique_team_names))
	  team_inds <- seq(from=1, to=length(unique_team_names), by=1)
	  print(team_inds)
	  print(results_for_teams)
	  print(true_wins_for_teams)
	  
	  plot(team_inds, results_for_teams, col = "red", xlab = "Team", ylab = new_year_string, ylim=c(10, 90), main=title)
	  
	  points(team_inds, true_wins_for_teams, col = "grey")
	  legend("topright", legend = c("Predicted wins", "Actual Wins"), col = c("red", "grey"), pch=1)
	  
	  # Compute the residuals
	  # residuals <- results - future_data$W
	  
	  # Return both the predicted values and residuals
	  # return(list(predictions = results, residuals = residuals))
#	  return (3)
# }


# predict_on_training_data(advanced_stats, advanced_stats_lasso_model, aparam, "Lasso AParam Prediction on Training Data")



```
Conducting additional residual analysis
```{r}
plot_residuals <- function(residuals, predicted_values, wins, residual_title) {
	# Step 1: Plotting the residuals
	# Plotting the predicted values against the residuals
	plot(predicted_values, residuals, xlab="Predicted Wins", ylab="Residuals", main=residual_title)
	# Plotting the actual wins as points to compare with predicted wins
	points(predicted_values, wins, col = "grey")
	# Adding a horizontal line at y=0 to indicate the zero residual line
	abline(h=0, lty=2)
}

check_residual_normality <- function(residuals, predicted_values, title) {
	# Step 2: Check for normality of residuals
	# Creating a histogram of the residuals
	ggplot(data = data.frame(residuals = residuals), aes(x = residuals)) +
	  geom_histogram() +
	  labs(x = "Residuals", y = "Frequency") +
	  ggtitle(title)
	
	# Creating a QQ plot of the residuals
	ggplot(data = data.frame(residuals = residuals), aes(sample = residuals)) +
	  stat_qq() +
	  stat_qq_line() +
	  labs(x = "Theoretical quantiles", y = "Sample quantiles") +
	  ggtitle(title)
}

check_residual_hetero <- function(residuals, predicted_values, title) {
	# Step 3: Check for heteroscedasticity
	# Plotting the residuals against the predicted values
	ggplot(data = data.frame(residuals = residuals, predicted_values = predicted_values),
	       aes(x = predicted_values, y = residuals)) +
	  geom_point() +
	  labs(x = "Predicted values", y = "Residuals") +
	  ggtitle(title)
}

plot_residuals(residuals_future_lasso$residuals, residuals_future_lasso$predictions, advanced_stats_2021$W, "Residual Analysis on Lasso AParam Prediction")
check_residual_normality(residuals_future_lasso$residuals, residuals_future_lasso$predictions, "Residual Analysis on Lasso AParam Prediction")
check_residual_hetero(residuals_future_lasso$residuals, residuals_future_lasso$predictions, "Residual Analysis on Lasso AParam Prediction")

plot_residuals(residuals_future_ridge$residuals, residuals_future_ridge$predictions, advanced_stats_2021$W, "Residual Analysis on Ridge AParam Prediction")
check_residual_normality(residuals_future_ridge$residuals, residuals_future_ridge$predictions, "Residual Analysis on Ridge AParam Prediction")
check_residual_hetero(residuals_future_ridge$residuals, residuals_future_ridge$predictions, "Residual Analysis on Ridge AParam Prediction")

plot_residuals(residuals_future_lasso_min$residuals, residuals_future_lasso_min$predictions, advanced_stats_2021$W, "Residual Analysis on Lasso Min AParam Prediction")
check_residual_normality(residuals_future_lasso_min$residuals, residuals_future_lasso_min$predictions, "Residual Analysis on Lasso Min AParam Prediction")
check_residual_hetero(residuals_future_lasso_min$residuals, residuals_future_lasso_min$predictions, "Residual Analysis on Lasso Min AParam Prediction")

plot_residuals(residuals_future_ridge_min$residuals, residuals_future_ridge_min$predictions, advanced_stats_2021$W, "Residual Analysis on Ridge Min AParam Prediction")
check_residual_normality(residuals_future_ridge_min$residuals, residuals_future_ridge_min$predictions, "Residual Analysis on Ridge Min AParam Prediction")
check_residual_hetero(residuals_future_ridge_min$residuals, residuals_future_ridge_min$predictions, "Residual Analysis on Ridge Min AParam Prediction")


```
